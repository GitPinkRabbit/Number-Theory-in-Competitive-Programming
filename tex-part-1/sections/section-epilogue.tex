% !TeX root = ../NTCP-Part-1.tex

\section{总结与注记}
\begin{frame}
  \frametitle{总结}
  \PKMissing{别急}
\end{frame}
\begin{frame}[c]
  \thankspage
\end{frame}
\subsection{\Cpp{} 中整型的 \texttt{/} 和 \texttt{\%} 运算符}\label{appcppdivmod}
\begin{frame}[c]
  \progressnow*
\end{frame}
\begin{frame}
  \frametitle{\Cpp{} 中\textbf{内置类型}的 \texttt{/} 和 \texttt{\%} 运算符}
  在 \Cpp{} 中，提供了\alert{除法运算符}“\texttt{/}”和\alert{求余运算符}“\texttt{\%}”以支持 \Cpp{} 程序进行相关计算。它们的形式为：
  \begin{itemize}
    \item “\texttt{\textcolor{gray}{左操作数} / \textcolor{gray}{右操作数}}”，
    \item “\texttt{\textcolor{gray}{左操作数} \% \textcolor{gray}{右操作数}}”。
  \end{itemize}
  \pause
  
  \emptyline
  众所周知，\Cpp{} 中有两类\textbf{内置}的数值类型，分别是\alert{整数类型}和\alert{浮点类型}。
  \begin{itemize}
    \item 整型的例子：\texttt{int}、\texttt{long long} 与它们的无符号版本、以及 \texttt{char}。
    \item 浮点型的例子：\texttt{float}、\texttt{double}、以及 \texttt{long double}。
  \end{itemize}
  \pause
  其中，浮点型之间可以进行 \texttt{/} 运算，但\textboldcolor[orange]{不能}进行 \texttt{\%} 运算。
  
  当整型与浮点型之间进行运算时，会将整型操作数转换为浮点型。
  \pause
  
  \emptyline
  当然，我们关注的是整型之间的 \texttt{/} 和 \texttt{\%} 运算。
\end{frame}
\begin{frame}
  \frametitle{整型的 \texttt{/} 运算的舍入方向}
  从 \Cpp{}11 标准开始，规定了 \texttt{/} 运算符的舍入方向：运算结果为第一操作数除以第二操作数的数值结果（一个小数）\textboldcolor[orange]{向零舍入}得到的整数。
  \pause
  
  \emptyline
  换句话说，运算结果\alert{在绝对值上}总是小于等于数值结果。
  
  更具体地，如果数值结果 $> 0$，则运算结果 $\le$ 数值结果，\\
  \-\hspace{7em}数值结果 $< 0$，则运算结果 $\ge$ 数值结果，\\
  \-\hspace{7em}数值结果 $= 0$，则运算结果 $=$ 数值结果 $= 0$。
  \pause
  
  \emptyline
  与前文“有余数的除法”不同，\Cpp{} 中 \texttt{/} 和 \texttt{\%} 的\alert{第二操作数均可以为负}。
  \pause
  
  \emptyline
  特别地，如果第二操作数为 $0$，则行为未定义（UB）。典型的编译器实现可能导致运行时错误（RE）。
\end{frame}
\begin{frame}
  \frametitle{整型的 \texttt{\%} 运算}
  \Cpp{} 保证了：若 $a \mathbin{\texttt{\%}} m = r$ 以及 $a \mathbin{\texttt{/}} m = q$，则一定有 $a = q \mathbin{\texttt{*}} m \mathbin{\texttt{+}} r$。
  
  特别地，若 $a \mathbin{\texttt{/}} m$ 会触发未定义行为，则 $a \mathbin{\texttt{\%}} m$ 的行为也未定义。
  \pause
  
  \emptyline
  对比前文“有余数的除法”与 \Cpp{} 中整型的 \texttt{/} 和 \texttt{\%} 运算符，异同之处在于：
  \begin{itemize}
    \item 相同点：
    \begin{visibleenv}<3->
      \begin{itemize}
        \item 当 $a$ 是非负数且 $m$ 是正数时，两者的结果相同。
        \item 即使 $a$ 是负数，当 $m$ 是正数且 \textboldcolor[orange]{$a$ 是 $m$ 的倍数}时，两者的结果也相同。
        \item 当 $m = 0$ 时，两者都是“未定义”的。
      \end{itemize}
    \end{visibleenv}
    \item 不同点：
    \begin{visibleenv}<4->
      \begin{itemize}
        \item 当 $m$ 是负数时，“有余数的除法”没有定义，但在 \Cpp{} 中有定义。
        \item 当 $m$ 是正数且 $a$ 是负数时，记 $a \div m = r_1$ 而 $a \mathbin{\texttt{/}} m = r_2$，则 $r_2$ 要么与 $r_1$ 相等，要么比 $r_1$ 大 $1$。
      \end{itemize}
    \end{visibleenv}
  \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{例子}
  \begin{itemize}
    \item \texttt{ 5 / \ 3} 与 \texttt{ 5 \% \ 3} 的结果分别为 \fillblank*<2->[red]{\texttt{ 1}} 与 \fillblank*<2->[red]{\texttt{ 2}}。
    \pause
    \pause
    \item \texttt{ 5 / -3} 与 \texttt{ 5 \% -3} 的结果分别为 \fillblank*<4->[red]{\texttt{-1}} 与 \fillblank*<4->[red]{\texttt{ 2}}。
    \pause
    \item \texttt{-5 / \ 3} 与 \texttt{-5 \% \ 3} 的结果分别为 \fillblank*<5->[red]{\texttt{-1}} 与 \fillblank*<5->[red]{\texttt{-2}}。
    \pause
    \item \texttt{-5 / -3} 与 \texttt{-5 \% -3} 的结果分别为 \fillblank*<6->[red]{\texttt{ 1}} 与 \fillblank*<6->[red]{\texttt{-2}}。
    \pause
    \pause
    \item \texttt{-7 / \ 0} 与 \texttt{-7 \% \ 0} 都是 \fillblank<8->[red]{未定义行为}。
    \pause
    \item \texttt{ 0 / \ 0} 与 \texttt{ 0 \% \ 0} 都是 \fillblank<9->[red]{未定义行为}。
  \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{正负性提示}
  假设 $a \mathbin{\texttt{/}} m = q$ 和 $a \mathbin{\texttt{\%}} m = r$。
  
  则有 $q$ 的正负性与 $a \cdot m$ 的正负性相同，\\
  \-\hspace{1em}而 $r$ 的正负性与 $a$ 的正负性相同。
  
  \emptyline
  在操作数可能为负数或 $0$ 时，需要特别注意。
  \pause
  
  \emptyline
  为了身心健康，避免记忆乱七八糟的情况，良好的代码实践是：
  \begin{center}
    \textboldcolor[darkgreen]{尽量保证第一操作数为\textboldcolor[orange]{非负整数}、第二操作数为正整数。}
  \end{center}
  \pause
  
  在 \Cpp{} 代码实现上，除此之外，还有其他注意事项，请看下页。
\end{frame}
\begin{frame}
  \frametitle{\textbf{代码注意事项}：整数提升和整数转换}
  在 \Cpp{} 中，整型之间的算术运算将经过两道关卡：\alert{整数提升}和\alert{整数转换}。
\end{frame}
\begin{frame}
  \frametitle{\textbf{代码注意事项}：整数提升}
  可以认为\alert{整数提升}是，将“小于 \texttt{int}”的类型转换到 \texttt{int} 或 \texttt{unsigned int}。例如对 \texttt{bool}、\texttt{char}、\texttt{short} 或它们的有或无符号版本进行转换。特殊情况按下不表。\textboldcolor[orange]{整数提升\CJKunderdot[format=\color{orange}]{总是保留原数值不变}。整型算术运算\CJKunderdot[format=\color{orange}]{总是}先将两操作数进行整数提升。}
  
  \emptyline
  例如，在 \texttt{char} 之间的减法，实际上会转换为 \texttt{int} 进行。
  
  \emptyline
  如果从不进行小于 \texttt{int} 的类型的算术运算，则无需担心整数提升。
\end{frame}
\begin{frame}
  \frametitle{\textbf{代码注意事项}：整数转换}
  \alert{整数转换}可能对数值进行更改。具体地，进行整型算术运算时，会产生被称作“\alert{公共类型}”的结果类型，同时两操作数也会\textbf{先转换为公共类型}。
  
  \emptyline
  问题在于：当一操作数为有符号，另一操作数为无符号，且无符号操作数的“等级”大于或等于有符号操作数的“等级”时，产生的公共类型就是\textboldcolor[orange]{无符号操作数的类型}。此时将有符号操作数转换为公共类型时，可能发生数值更改。
  \pause
  
  \emptyline
  例如，计算 \texttt{-5 / 3u} 时，产生的公共类型为 \texttt{unsigned int}，此时先将 \texttt{-5} 转换得到 \texttt{4294967291u}，进行除法得到结果 \texttt{1431655763u}，与期望的 \texttt{-1} 不同。
  \pause
  同样地，良好的实践是：
  \begin{center}
    \textboldcolor[darkgreen]{尽量避免\CJKunderdot[format=\color{darkgreen}]{混合使用}有、无符号类型进行 \texttt{/} 或 \texttt{\%} 运算（及其他算术运算）。}
  \end{center}
\end{frame}
\subsection*{附录 B}
\begin{frame}{别急}\PKMissing{别急}\end{frame} % delete this ==================
\subsection*{附录 C}
\begin{frame}{别急}\PKMissing{别急}\end{frame} % delete this ==================
